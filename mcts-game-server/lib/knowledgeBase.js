// an abstraction of neo4j calls
// a wrapper for cypher queries and the request module
'use strict';
{
	module.exports = {
		createNewRoot,
		getNode,
		mergeNode,
		createChildren,
		backup,
		bestChild,
		treePolicy
	}

	/**
	 * JSON representation of neo4j tree objects
	 * @property {Object} TreeNode               - neo4j board state tree node object
	 * @param {Number}    TreeNode.index         - hashed board value
	 * @param {String}    TreeNode.board         - stringified, generalized RiskBoard object
	 * @param {Boolean}   TreeNode.nonTerminal   - is this board a game over state?
	 * @param {Number}    TreeNode.rewards 		   - non-negative value increased by 1 for every winning outcome simulated by nodes in this branch
	 * @param {Number}    TreeNode.visits	       - how many times a simulation has been run on this node or any of its children
	 * @param {Number}    TreeNode.createdAt     - Epoch time date representation when this node was generated
	 */

	var config = require('config')
		, auth = new Buffer(config.get('neo4j.username') + ':' + config.get('neo4j.password'))
		, request = require('request')
		, _ = require('lodash')
		, Q = require('q')
		, async = require('async')
		, CLIPS = require('../lib/clipsController.js')
		, neo4jParser = require('neo4j-parser')
		, neo4j = request.defaults({
			method: 'POST',
			url: config.get('neo4j.baseUrl'),
			headers: {
				Authorization: 'Basic ' + auth.toString('base64')
			}
		})
		, explorationParameter = config.get('mcts.explorationParameter')
		, infinity = config.get('mcts.infinity')
		, helper = require('./knowledgeBase.helper.js')


	/**
	 * gets a board node from neo4j by its index
	 * @param  {Number} index  - a hash value generated by knowledgeBase.helper.hash
	 * @return {Object}        - neo4j BOARD object
	 */
	function getNode(index) {
		var deferred = Q.defer();

		neo4j({json:helper.constructQueryBody(`MATCH (p:BOARD {index:${index}}) RETURN p`)},
			function(err, res, body) {
				if (err) {
					deferred.reject(new Error('[knowledgeBase.getNode()]: request resulted in error: \n' + JSON.stringify(err)));
				}
				var result = _.get(body, 'results[0].data[0].row[0]')
				deferred.resolve(result)
			})

		return deferred.promise;
	}

	/**
	 * gets or creates a board node object
	 * @param  {Object} board  - generalized board object
	 * @return {Object}        - neo4j BOARD object
	 */
	function mergeNode(board) {
		var deferred = Q.defer()
			, serializedBoard = helper.serialize(board)
			, hashBoard = helper.hash(serializedBoard)
			, query = [
					`
						MERGE (p:BOARD {index:${hashBoard}})
						ON CREATE SET p.nonTerminal = true, p.rewards = 0, p.visits = 0, p.createdAt = timestamp(), p.board = '${serializedBoard}'
						RETURN p
					`,
					`
						MATCH (p:BOARD {index:${hashBoard}}) - [a:CHILD]- ()
						RETURN a
					`]

			, payload = helper.constructQueryBody(query,[{},{}])
		neo4j({json:payload},
			function(err, res, body) {
				var neo4jError = _.get(body, 'errors')
					, errors = err || ((neo4jError.length > 0) ? neo4jError : null);
				if (errors) {
					deferred.reject(errors);
				} else {
					var board = _.get(body, 'results[0].data[0].row[0]')
						, actionData = _.get(body, 'results[1].data')
						, actions = []
					_.forEach(actionData, function(d) {
						var	thisAction = _.get(d, 'row[0]')
						if (thisAction) {
							actions.push(thisAction)
						}
					})
					var needToExpand = (actions.length > 0 ? false : true);
					if (needToExpand) {
						// @todo: if actions.length > 0, expand().then(function(){ createChildren().then(function() { deferred.resolve() }) })
						// this is how we deal with the situation where a new node is created. it will not yet have
						// any possibleMoves.  we need to expand it and then create it's children then finally return
						// the board.
					}
					deferred.resolve(board)  // @todo: all entities in boards[] should be identical. check by _.uniq()?
				}
			})

		return deferred.promise;
	}

	/**
	 * creates a root node in the knowledge base
	 * @param  {Object[]} moves     - array of valid moves from state
	 * @param  {TreeNode} board     - game board object (should be generated via variant.generate())
	 * @return {Promise}            - Promise that returns the created root node on success
	 */
	function createNewRoot(board, moves) {
		var deferred = Q.defer();
		// @todo: validate board instanceof BoardObject.  likely a function attached to variant.
		// in order to do this, variant would need to be a singleton and shared to all
		// node code.  :-(
		if (!typeof board === 'object') {
			deferred.reject(new Error('[knowledgeBase.createNewRoot()]: board (arg1) should be an object'));
			return deferred.promise;
		} else 
	  if (!Array.isArray(moves)) {
	  	deferred.reject(new Error('[knowledgeBase.createNewRoot()]: arg 2 ("moves") should be an array'));
	  	return deferred.promise;
	  } else {
	  	var serializedBoard = helper.serialize(board)
	  		, hashBoard = helper.hash(serializedBoard)
				, params = {
					boardParams: {
						nonTerminal: true,
						index: hashBoard,
						board: serializedBoard,
						rewards: 0,
						visits: 0,
						createdAt: Date.now()
					},
					possibleMoves: moves
				}
				// @TODO: check if already exists, and just return it.
				, statement = `
						MERGE (p:BOARD {index:${hashBoard}})
						ON CREATE SET p.nonTerminal = true, p.rewards = 0, p.visits = 0, p.createdAt = timestamp(), p.board = '${serializedBoard}'
						FOREACH (move in {possibleMoves} | 
			 		  	MERGE (p) -[:POSSIBLE {name: move.name, params: move.params}]-> (n:UNEXPLORED {index: ${hashBoard}}))
				 		RETURN p`
				, payload = helper.constructQueryBody(statement, params)
			neo4j({json:payload}, function(err, res, body) {
				var neo4jError = _.get(body, 'errors')
					, errors = err || ((neo4jError.length > 0) ? neo4jError : null);
				if (errors) {
					deferred.reject(errors);
				} else {
					var result = {};
					result.root = _.get(body, 'results[0].data[0].row[0]')  // parses neo4j response structure
					deferred.resolve(result)
				}
			});
		}
		return deferred.promise;
	}

	/**
	 * creates children of a parent node by way of the move that generated them.  called after simulation.expand()
	 * @param  {TreeNode} parent                 - parent node (a BOARD properties object)
	 * @param  {Number}   parent.index           - hash value of existing parent object in database
	 * @param  {Object}   move                   - a valid move object (see wiki for example)
	 * @param  {Object[]} children               - generalized board objects, the result of simulation.expand()
	 * @param  {String}   children[].board       - child board state
	 * @param  {Object[]} children[].moves       - valid moves from the child state
	 * @param  {Boolean}  children[].nonTerminal - flag indicating it is an end of game configuration
	 * @return {Promise}                         - resolves to 'success', else it will reject 
	 */
	function createChildren(parent, move, children) {
		// TODO: input validation
		if (!typeof parent === 'object' && !parent.hasOwnProperty('index')) {
			deferred.reject('[knowledgeBase.createChildren()]: parent (arg1) should be an object with an index property, got: ' + JSON.stringify(parent));
			return deferred.promise;
		} else if (!typeof move === 'object') {
			deferred.reject('[knowledgeBase.createChildren()]: move (arg2) should be an object');
			return deferred.promise;
		} else if (!Array.isArray(children)) {
			deferred.reject('[knowledgeBase.createChildren()]: children (arg3) should be an array');
			return deferred.promise;
		} else {
			var deferred = Q.defer()
				, statements = []
				, parameters = []
				, hashParentBoard = parent.index;

			_.forEach(children, function(child) {
				let thisBoard = _.get(child, 'board');
				if (!thisBoard) {
					throw new Error('[knowledgeBase.createChildren()]: a child in children is missing board property: \n' + JSON.stringify(child));
				}
				let serializedBoard = helper.serialize(child.board)
	  			, hashChildBoard = helper.hash(serializedBoard)
	  			, params = {
						child: {
							nonTerminal: child.nonTerminal,
							index: hashChildBoard,
							board: serializedBoard,
							rewards: 0,
							visits: 0,
							createdAt: Date.now()
						},
						possibleMoves: child.moves,
						move: move
					}
					, query = `
							CREATE (c:BOARD {child})
							WITH c
							FOREACH (move in {possibleMoves} | 
								CREATE (n:UNEXPLORED {index: ${hashChildBoard}})
					 		  CREATE (c) -[:POSSIBLE {name: move.name, params: move.params}]-> (n))
				 		  WITH c
							MATCH (p:BOARD {index: ${hashParentBoard}})
							WITH c, p
							CREATE (p) -[cr:CHILD {move}]-> (c)
							CREATE (c) -[pr:PARENT {move}]-> (p)
							RETURN collect(c) AS result`
				statements.push(query);
				parameters.push(params);
			})
			// delete 'possible' relation associated with this 'create' call
			statements.push(`
				WITH {move} AS m
				MATCH (p:BOARD {index: ${hashParentBoard}}) -[r {name: m.name}]- (u:UNEXPLORED {index:${hashParentBoard}})
				DELETE r, u
			`)		
			parameters.push({move: move})

			var payload = helper.constructQueryBody(statements, parameters)
			// debug
			// deferred.reject(new Error('createChildren payload: ' + JSON.stringify(payload)))
			neo4j({json:payload}, function(err, response, body) {
				var neo4jError = _.get(body, 'errors')
					, errors = err || ((neo4jError.length > 0) ? neo4jError : null);
				if (errors) {
					deferred.reject(errors);
				} else {
					var result = []
						, childCount = _.get(body, 'results.length')
					for (var i = 0; i < childCount; ++i) {
						var child = {};
						// TODO: create helper to parse neo4j response object (or find one)
						child = _.get(body, 'results[' + i + '].data[0].row[0]');
						result.push(child)
					}
					deferred.resolve(result)
				}
			})
			return deferred.promise;
		}
	}


	/**
	 * backup operation for Monte Carlo Tree Search
	 * @param  {Object} child        - child board state we will backup from
	 * @param  {String} root         - root board state, from variant.generate()
	 * @param  {Integer} reward      - delta reward calculated by simulation.defaultPolicy()
	 * @return {Promise}             - string 'success' or error object if failed
	 */
	function backup(child, root, reward) {
		var deferred = Q.defer()
		if (typeof reward !== 'number') {
			deferred.reject(new Error('[knowledgeBase.backup]: reward ' + reward + ' is not a number'));
			return deferred.promise;
		} else if (typeof child !== 'object' || typeof root !== 'object') {
			deferred.reject(new Error('[knowledgeBase.backup]: child state: "' + (typeof child) + '", root state: "' + (typeof root) + '". both should be objects.'))
			return deferred.promise;
		} else {
			var hashChildBoard = helper.hash(helper.serialize(child))
				, hashRootBoard = helper.hash(helper.serialize(root))
				, query = `
						MATCH (child:BOARD{index: ${hashChildBoard}}),(root:BOARD {index: ${hashRootBoard}}),
						path = (child) -[:PARENT*]-> (root)
						WITH nodes(path) AS pathNodes UNWIND pathNodes as node
						WITH DISTINCT node
						SET node.visits = node.visits + 1, node.rewards = node.rewards + ${reward}
						RETURN collect(node)`
				, payload = helper.constructQueryBody(query)
			neo4j({json:payload}, function(err, response, body) {
				var neo4jError = _.get(body, 'errors')
					, errors = err || ((neo4jError.length > 0) ? neo4jError : null);
				if (errors) {
					deferred.reject(errors);
				} else {
					deferred.resolve('success')
				}
			})
			return deferred.promise;
		}
	}

	/**
	 * bestChild operation in Monte Carlo Tree Search, using UCT method. finds the bestChild of a parent board and returns it along with the move that creates the child
	 * @param  {Object} parent - parent generalized board state object
	 * @param  {Integer}    Cp - the coefficient used in UCT for the second term. See essay on MCTS methods.
	 * @return {Promise}       - Promise that resolves to a tuple of board state object, move object; or, an error
	 */
	function bestChild(parent, Cp) {
		var deferred = Q.defer()
			, hashParentBoard = helper.hash(helper.serialize(parent))
			, query = `
					MATCH (p:BOARD {index:${hashParentBoard}}) -[r:CHILD]-> (c:BOARD)
					WITH collect(c) AS children, r AS moves, p AS parent
					RETURN EXTRACT(child in children |
							CASE 
							WHEN child.visits = 0
							THEN {board:child.board, nonTerminal: child.nonTerminal, uct: ${infinity}}						
							ELSE {
					      board: child.board, 
					      nonTerminal: child.nonTerminal,
					      uct: 
					      	((toFloat
					      			(child.rewards) / child.visits)
					       		+ ${Cp}
					       			* SQRT(
					        			(2.0 * LOG(parent.visits))
					        		/ child.visits)
					       		)
					    }
				  	END)
			  	AS uct, moves`
					// TODO: within query, "ORDER BY uct DESC LIMIT 1"
		var payload = helper.constructQueryBody(query)
		neo4j({json:payload}, function(err, response, body) {
			var neo4jError = _.get(body, 'errors')
				, errors = err || ((neo4jError.length > 0) ? neo4jError : null);
			if (errors) {
				deferred.reject(errors);
			} else {
				var result = []
					, childCount = _.get(body, 'results[0].data.length')
				for (var i = 0; i < childCount; ++i) {
					var child = {};
					// TODO: create helper to parse neo4j response object (or find one)
					child.board = _.get(body, 'results[0].data[' + i + '].row[0][0]');
					child.move = _.get(body, 'results[0].data[' + i + '].row[1]');
					result.push(child)
				}
				result.sort(function(a,b) {
					return b.board.uct - a.board.uct;
				})
				// deferred.resolve(_.get(result, '[0]'))
				var bestChild = _.get(_.head(result), 'board');
				if (!bestChild) {
					throw new Error('[knowledgeBase.bestChild()]: neo4j returned result but it did not contain the expected structure: \n' + JSON.stringify(result) + '\n')
				}
				deferred.resolve(bestChild)
			}
		})
		return deferred.promise;
	}


	/**
	 * treePolicy method as described in Monte Carlo Tree Search. searches for a best child board state to pass to our defaultPolicy for simulation.
	 * @param  {Object} root - generalized board state for the root of this treePolicy search
	 * @return {Promise}     - resolves to a board state object, rejects with any error messages.
	 */
	function treePolicy(root) {
		var deferred = Q.defer()
			, hashBoard = helper.hash(helper.serialize(root))
			, v = root
			, expandableMoveNotFound = true;
		async.doWhilst(function(callback) {
			var query = `
				MATCH (b:BOARD {index:${v.index}}) -[r:POSSIBLE]-> ()
				WITH r, count(*) as possibleMoveCount
				RETURN
				CASE possibleMoveCount > 0
				WHEN true
				THEN r
				WHEN false 
				THEN false
				END AS expand`
			, payload = helper.constructQueryBody(query)
			neo4j({json:payload}, function(err, _res, body) {
				var neo4jError = _.get(body, 'errors')
					, errors = err || ((neo4jError.length > 0) ? neo4jError : null);
				if (errors) {
					callback(errors);
				} else {
					// grab first move. order guaranteed? not guaranteed? probs not.
					// console.log('treePolicy result from finding possible moves:')
					// console.log(JSON.stringify(body))
					var move = _.get(body, 'results[0].data[0].row[0]')
					if (move) {
						expandableMoveNotFound = false;  // end async.whilst() loop
						CLIPS.expand(v, move)
							.then(function(children) {
								createChildren(v, move, children)
									.then(function(result) {
										// @TODO: confirm that we are always grabbing the result from createChildren.
										// the neo4j response structure is always an array due to collect(c);
										// but is it ever multiple arrays in multiple rows due to possible multiplicity
										// of children generated?
										v = _.head(_.head(result));
										if (!v) {
											let len = _.get(children, 'length')
											throw new Error('[knowledgeBase.treePolicy()]: created children from ' + len + ' children but _.head() of result from createChildren() is falsey:\n' + JSON.stringify(v))
										}
										callback(null) // doWhilst(): end this iteration
									})
									.catch(function(createError) {
										callback(createError)
									})
							})
					} else {
						bestChild(v, explorationParameter)
							.then(function(vBestChild) {
								v = _.get(vBestChild, 'board')
								if (v) {
									callback(null)
								} else {
									callback(new Error('[treePolicy]: could not look up board state string of bestChild() with v: ' + JSON.stringify(v) + ' from bestChild result: \n ' + JSON.stringify(vBestChild)))
								}		
							})
							.catch(function(bestChildError) {
								callback(bestChildError)
							})
						// copied from bestChild() above (before refactoring to not set c.uct)
					}
				}
			})
		},
		function whileTest () { 
			return (expandableMoveNotFound && v.nonTerminal);
		},
		function result (error, result) {
			if (error) {
				deferred.reject(error);
			} else {
				deferred.resolve(v)
			}
		})
  	return deferred.promise;
	}	  	
}